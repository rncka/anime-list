<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>애니리스트</title>

  <!-- iPhone / 홈 화면 아이콘 (원하는 512x512 PNG 파일명으로 수정 가능) -->
  <link rel="apple-touch-icon" href="icon_512.png" />
  <link rel="icon" type="image/png" href="icon_512.png" />

  <style>
    :root[data-theme="light"] {
      --bg: #f3f4f6;
      --text: #111827;
      --subtext: #4b5563;
      --row-bg: #ffffff;
      --border: #e5e7eb;
      --accent: #38bdf8;
      --danger: #f97373;
      --chip-text: #111827;
    }

    :root[data-theme="dark"] {
      --bg: #020617;
      --text: #e5e7eb;
      --subtext: #9ca3af;
      --row-bg: #020617;
      --border: #1e293b;
      --accent: #38bdf8;
      --danger: #f97373;
      --chip-text: #f9fafb;
    }

    * { box-sizing: border-box; }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      padding: 20px;
      margin: 0;
      background: radial-gradient(circle at top, #0f172a 0, var(--bg) 45%);
      color: var(--text);
    }

    .app { max-width: 980px; margin: 0 auto; }

    /* ===== 제목 영역 ===== */
    .app-header {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      margin-bottom: 18px;
      text-align: center;
    }

    h1 {
      margin: 0;
      font-size: 28px;
      letter-spacing: 0.08em;
    }

    .header-actions {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .badge {
      font-size: 11px;
      padding: 3px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: var(--subtext);
    }

    .theme-select {
      font-size: 12px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: var(--row-bg);
      color: var(--text);
    }

    /* ===== 입력 / 필터 영역 ===== */
    .controls { margin-bottom: 10px; }

    .input-row {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
      flex-wrap: wrap;
    }

    input,
    select,
    button {
      font-size: 13px;
      padding: 6px 9px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: var(--row-bg);
      color: var(--text);
      outline: none;
    }

    input::placeholder { color: var(--subtext); }

    input:focus,
    select:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.4);
    }

    button {
      cursor: pointer;
      border-radius: 999px;
      border: none;
      background: linear-gradient(135deg, #38bdf8, #6366f1);
      color: #f9fafb;
      padding-inline: 14px;
      font-weight: 500;
      white-space: nowrap;
      transition: transform 0.12s ease-out, box-shadow 0.12s ease-out, opacity 0.12s;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 10px rgba(15, 23, 42, 0.5);
      opacity: 0.95;
    }

    button.secondary {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--subtext);
      box-shadow: none;
    }
    button.secondary:hover {
      box-shadow: 0 3px 8px rgba(15, 23, 42, 0.4);
      background: rgba(148, 163, 184, 0.1);
    }

    button.danger { background: #b91c1c; }

    .small-btn { padding: 3px 8px; font-size: 11px; }

    .search-input {
      flex: 1;
      min-width: 180px;
    }

    .summary-row {
      font-size: 13px;
      color: var(--subtext);
      margin-bottom: 6px;
    }

    .filter-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    /* 상태 탭 */
    .status-tabs {
      display: inline-flex;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.75);
      border: 1px solid var(--border);
      padding: 2px;
      gap: 2px;
    }

    .status-tab {
      border: none;
      background: transparent;
      color: var(--subtext);
      font-size: 12px;
      padding: 4px 10px;
      border-radius: 999px;
      cursor: pointer;
      transition: background 0.12s ease-out, color 0.12s ease-out, transform 0.08s;
    }

    .status-tab:hover {
      transform: translateY(-1px);
      background: rgba(148, 163, 184, 0.2);
    }

    .status-tab.active {
      background: linear-gradient(135deg, #38bdf8, #6366f1);
      color: #f9fafb;
    }

    /* ===== 리스트 형식 + 애니메이션 ===== */
    .grid {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-top: 8px;
    }

    @keyframes fadeInUp {
      from { opacity: 0; transform: translateY(6px); }
      to   { opacity: 1; transform: translateY(0); }
    }

    .card {
      display: grid;
      grid-template-columns: minmax(0, 2.8fr) minmax(0, 2.2fr) minmax(0, 1.6fr);
      gap: 4px 12px;
      align-items: center;
      padding: 10px 12px;
      background: var(--row-bg);
      border-radius: 14px;
      border: 1px solid var(--border);
      box-shadow: 0 2px 6px rgba(15, 23, 42, 0.45);
      animation: fadeInUp 0.22s ease-out;
      transition: transform 0.14s ease-out, box-shadow 0.14s ease-out, background-color 0.18s;
    }

    .card:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(15, 23, 42, 0.7);
      background-color: rgba(15, 23, 42, 0.9);
    }

    .card-header {
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .title-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .card-title {
      font-size: 15px;
      font-weight: 600;
      word-break: keep-all;
    }

    .card-meta {
      font-size: 12px;
      color: var(--subtext);
    }

    .episode-text {
      font-size: 12px;
      color: var(--subtext);
    }

    .status-chip {
      padding: 3px 8px;
      border-radius: 999px;
      font-size: 11px;
      font-weight: 600;
      color: var(--chip-text);
      white-space: nowrap;
      border: 1px solid transparent;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .status-chip.done {
      background: #14532d;
      border-color: rgba(34, 197, 94, 0.6);
    }
    .status-chip.watching {
      background: #78350f;
      border-color: rgba(245, 158, 11, 0.7);
    }
    .status-chip.not {
      background: #7f1d1d;
      border-color: rgba(248, 113, 113, 0.8);
    }

    .status-select-row {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-top: 4px;
      flex-wrap: wrap;
    }

    .pill {
      padding: 2px 6px;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.2);
      font-size: 11px;
      color: var(--subtext);
      white-space: nowrap;
    }

    .episode-row {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-top: 4px;
      flex-wrap: wrap;
    }

    .episode-label {
      font-size: 11px;
      color: var(--subtext);
      padding: 2px 6px;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.18);
    }

    .wheel-select {
      padding: 4px 10px;
      font-size: 12px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: var(--bg);
      color: var(--text);
    }

    .memo-input {
      margin-top: 4px;
      width: 100%;
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: 5px 10px;
      font-size: 13px;
      background: rgba(15, 23, 42, 0.7);
      color: var(--text);
    }

    .card-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .empty {
      margin-top: 16px;
      font-size: 13px;
      color: var(--subtext);
      text-align: center;
    }

    @media (max-width: 720px) {
      body { padding: 14px; }
      .card {
        grid-template-columns: 1fr;
        align-items: flex-start;
      }
      .card-footer {
        flex-direction: column;
        align-items: flex-start;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <header class="app-header">
      <h1>애니리스트</h1>
      <div class="header-actions">
        <select id="themeSelect" class="theme-select">
          <option value="dark">다크 모드</option>
          <option value="light">라이트 모드</option>
        </select>
        <span class="badge">상태 · 시즌 · 회차 · 메모 모두 자동 저장</span>
      </div>
    </header>

    <section class="controls">
      <div class="input-row">
        <input id="titleInput" placeholder="작품 이름" />
        <input id="episodeInput" placeholder="회차 (예: 1기 3화)" />
        <select id="seenInput">
          <option value="O">O · 다 봄</option>
          <option value="W">△ · 보는 중</option>
          <option value="X">X · 안 봄</option>
        </select>
        <input id="memoInput" placeholder="메모 (만화/애니/기타)" />
        <button id="addBtn">+ 추가</button>
        <button id="clearBtn" class="danger">전체 삭제</button>
      </div>

      <div class="input-row filter-row">
        <input id="searchInput" class="search-input" placeholder="제목 검색" />
        <select id="sortSelect">
          <option value="createdDesc">최근 추가순</option>
          <option value="titleAsc">이름순 (가나다)</option>
        </select>

        <div class="status-tabs">
          <button class="status-tab active" data-filter="ALL">전체</button>
          <button class="status-tab" data-filter="W">보는 중</button>
          <button class="status-tab" data-filter="O">다 봄</button>
          <button class="status-tab" data-filter="X">안 봄</button>
        </div>
      </div>
    </section>

    <div id="summary" class="summary-row"></div>

    <div id="grid" class="grid"></div>
    <div id="empty" class="empty" style="display:none;">데이터가 없습니다. 위에서 작품을 추가해보세요.</div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.5.0/firebase-app.js";
    import {
      getFirestore,
      collection,
      addDoc,
      onSnapshot,
      query,
      orderBy,
      doc,
      updateDoc,
      deleteDoc,
      getDocs
    } from "https://www.gstatic.com/firebasejs/12.5.0/firebase-firestore.js";

    // --- Firebase 설정 ---
    const firebaseConfig = {
      apiKey: "AIzaSyDpbP8aBRqOQtLNLDbtrly49ozPon4SQaWE",
      authDomain: "anime-list-85c9e.firebaseapp.com",
      projectId: "anime-list-85c9e",
      storageBucket: "anime-list-85c9e.firebasestorage.app",
      messagingSenderId: "397442929562",
      appId: "1:397442929562:web:1b5e3e90cbbfa8a573d8e51"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const itemsCol = collection(db, "animeItems");

    // ---- 상태 변수 ----
    let items = [];
    let sortMode = "createdDesc";
    let filterSeen = "ALL";
    let searchQuery = "";

    // ---- DOM 참조 ----
    const themeSelect   = document.getElementById("themeSelect");
    const titleInput    = document.getElementById("titleInput");
    const episodeInput  = document.getElementById("episodeInput");
    const seenInput     = document.getElementById("seenInput");
    const memoInputTop  = document.getElementById("memoInput");
    const addBtn        = document.getElementById("addBtn");
    const clearBtn      = document.getElementById("clearBtn");
    const searchInput   = document.getElementById("searchInput");
    const sortSelect    = document.getElementById("sortSelect");
    const summaryEl     = document.getElementById("summary");
    const grid          = document.getElementById("grid");
    const emptyEl       = document.getElementById("empty");
    const statusTabs    = document.querySelectorAll(".status-tab");

    // ---- 유틸 함수 ----
    function normalizeSeen(v) {
      v = (v || "X").toUpperCase();
      if (v === "O" || v === "W" || v === "X") return v;
      return "X";
    }

    function getCreatedAtMs(item) {
      const v = item.createdAt;
      if (!v) return 0;
      if (typeof v === "number") return v;
      if (v.toMillis) return v.toMillis();
      return 0;
    }

    function buildEpisodeText(season, episodeNum) {
      let s = "";
      if (season != null) s += season + "기";
      if (episodeNum != null) {
        if (s) s += " ";
        s += episodeNum + "화";
      }
      return s;
    }

    // "1기 3화" 같은 문자열을 분리
    function parseEpisodeText(text) {
      text = (text || "").trim();
      if (!text) return { season: null, episodeNum: null, episodeText: "" };

      let season = null;
      let episodeNum = null;

      const seasonMatch = text.match(/(\d+)\s*기/);
      if (seasonMatch) season = Number(seasonMatch[1]);

      const epMatch = text.match(/(\d+)\s*화/);
      if (epMatch) episodeNum = Number(epMatch[1]);

      const episodeText = buildEpisodeText(season, episodeNum) || text;
      return { season, episodeNum, episodeText };
    }

    // 예전 episode 문자열을 자동으로 season/episodeNum에 반영
    function autoFixEpisodeStructure(item) {
      const raw = item.episodeText || item.episode || "";
      if (!raw) return null;

      const parsed = parseEpisodeText(raw);
      const seasonNew = parsed.season ?? null;
      const episodeNew = parsed.episodeNum ?? null;

      const currentSeason = item.season ?? null;
      const currentEpisode = item.episodeNum ?? null;

      if (seasonNew === currentSeason && episodeNew === currentEpisode) return null;

      return {
        season: seasonNew,
        episodeNum: episodeNew,
        episodeText: parsed.episodeText
      };
    }

    function debounce(fn, delay = 300) {
      let t;
      return (...args) => {
        clearTimeout(t);
        t = setTimeout(() => fn(...args), delay);
      };
    }

    // ---- 테마 ----
    const THEME_KEY = "animeListTheme";
    function setTheme(mode) {
      document.documentElement.dataset.theme = mode;
      localStorage.setItem(THEME_KEY, mode);
      themeSelect.value = mode;
    }

    (function initTheme() {
      const saved = localStorage.getItem(THEME_KEY) || "dark";
      setTheme(saved);
    })();

    themeSelect.addEventListener("change", (e) => {
      setTheme(e.target.value);
    });

    // ---- Firestore 실시간 구독 ----
    const q = query(itemsCol, orderBy("createdAt", "asc"));
    onSnapshot(q, (snapshot) => {
      items = [];
      snapshot.forEach((docSnap) => {
        items.push({ id: docSnap.id, ...docSnap.data() });
      });
      render();
    });

    // ---- 입력 이벤트 ----
    addBtn.addEventListener("click", addItem);
    titleInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") addItem();
    });
    episodeInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") addItem();
    });

    async function addItem() {
      const title = titleInput.value.trim();
      const episodeRaw = episodeInput.value.trim();
      const seen = seenInput.value;
      const memo = memoInputTop.value.trim();

      if (!title) {
        alert("작품 이름을 입력해주세요!");
        return;
      }

      const { season, episodeNum, episodeText } = parseEpisodeText(episodeRaw);

      await addDoc(itemsCol, {
        title,
        seen,
        type: memo,
        season,
        episodeNum,
        episodeText: episodeText || episodeRaw,
        createdAt: Date.now()
      });

      titleInput.value = "";
      episodeInput.value = "";
      memoInputTop.value = "";
      seenInput.value = "O";
    }

    clearBtn.addEventListener("click", async () => {
      if (!confirm("정말 전체 삭제할까요?")) return;
      const snap = await getDocs(itemsCol);
      const tasks = snap.docs.map((d) => deleteDoc(d.ref));
      await Promise.all(tasks);
    });

    searchInput.addEventListener("input", (e) => {
      searchQuery = e.target.value.trim().toLowerCase();
      render();
    });

    sortSelect.addEventListener("change", (e) => {
      sortMode = e.target.value;
      render();
    });

    statusTabs.forEach((tab) => {
      tab.addEventListener("click", () => {
        statusTabs.forEach((t) => t.classList.remove("active"));
        tab.classList.add("active");
        filterSeen = tab.dataset.filter;
        render();
      });
    });

    // ---- 렌더링 ----
    function render() {
      grid.innerHTML = "";

      // 요약 계산
      let countAll = items.length;
      let countO = 0, countW = 0, countX = 0;
      items.forEach((it) => {
        const s = normalizeSeen(it.seen);
        if (s === "O") countO++;
        else if (s === "W") countW++;
        else if (s === "X") countX++;
      });
      summaryEl.textContent = `전체 ${countAll} · O ${countO} · △ ${countW} · X ${countX}`;

      // 필터/검색/정렬
      let display = items.map((item) => ({
        ...item,
        seen: normalizeSeen(item.seen)
      }));

      if (searchQuery) {
        display = display.filter((item) =>
          (item.title || "").toLowerCase().includes(searchQuery)
        );
      }

      if (filterSeen !== "ALL") {
        display = display.filter((item) => normalizeSeen(item.seen) === filterSeen);
      }

      display.sort((a, b) => {
        if (sortMode === "titleAsc") {
          return (a.title || "").localeCompare(b.title || "", "ko");
        } else {
          return getCreatedAtMs(b) - getCreatedAtMs(a);
        }
      });

      if (display.length === 0) {
        emptyEl.style.display = "block";
        return;
      } else {
        emptyEl.style.display = "none";
      }

      display.forEach((item) => {
        const docRef = doc(db, "animeItems", item.id);

        // 예전 episode 문자열을 자동으로 season/episodeNum에 반영
        const fixed = autoFixEpisodeStructure(item);
        if (fixed) {
          updateDoc(docRef, fixed).catch(console.error);
          item = { ...item, ...fixed };
        }

        const season = item.season ?? null;
        const episodeNum = item.episodeNum ?? null;
        const episodeText =
          item.episodeText ||
          item.episode ||
          buildEpisodeText(season, episodeNum) ||
          "회차 정보 없음";

        const seen = normalizeSeen(item.seen);

        // --- 카드 생성 ---
        const card = document.createElement("div");
        card.className = "card";

        // ===== 왼쪽 영역: 제목 + 회차 + 메모 =====
        const left = document.createElement("div");
        left.className = "card-header";

        const titleRow = document.createElement("div");
        titleRow.className = "title-row";

        const titleEl = document.createElement("div");
        titleEl.className = "card-title";
        titleEl.textContent = item.title || "";

        const chip = document.createElement("div");
        chip.className = "status-chip";
        if (seen === "O") chip.classList.add("done");
        else if (seen === "W") chip.classList.add("watching");
        else chip.classList.add("not");
        chip.textContent =
          seen === "O" ? "다 봄" :
          seen === "W" ? "보는 중" : "안 봄";

        titleRow.appendChild(titleEl);
        titleRow.appendChild(chip);

        const epTextEl = document.createElement("div");
        epTextEl.className = "episode-text";
        epTextEl.textContent = episodeText;

        const memoInput = document.createElement("input");
        memoInput.className = "memo-input";
        memoInput.placeholder = "메모";
        memoInput.value = item.type || "";

        const saveMemo = debounce(async (value) => {
          await updateDoc(docRef, { type: value });
        }, 400);

        memoInput.addEventListener("input", (e) => {
          saveMemo(e.target.value.trim());
        });

        left.appendChild(titleRow);
        left.appendChild(epTextEl);
        left.appendChild(memoInput);

        // ===== 가운데 영역: 상태 + 시즌/회차 선택 =====
        const mid = document.createElement("div");

        const statusRow = document.createElement("div");
        statusRow.className = "status-select-row";

        const statusPill = document.createElement("div");
        statusPill.className = "pill";
        statusPill.textContent = "상태";

        const statusSelect = document.createElement("select");
        statusSelect.className = "wheel-select";
        statusSelect.innerHTML = `
          <option value="O" ${seen === "O" ? "selected" : ""}>O · 다 봄</option>
          <option value="W" ${seen === "W" ? "selected" : ""}>△ · 보는 중</option>
          <option value="X" ${seen === "X" ? "selected" : ""}>X · 안 봄</option>
        `;
        statusSelect.addEventListener("change", async (e) => {
          const val = e.target.value;
          await updateDoc(docRef, { seen: val });
        });

        statusRow.appendChild(statusPill);
        statusRow.appendChild(statusSelect);

        const epRow = document.createElement("div");
        epRow.className = "episode-row";

        const epLabel = document.createElement("div");
        epLabel.className = "episode-label";
        epLabel.textContent = "시즌 / 회차";

        const seasonSelect = document.createElement("select");
        seasonSelect.className = "wheel-select";
        const seasonOptions = ["시즌 없음"].concat(
          Array.from({ length: 10 }, (_, i) => `${i + 1}기`)
        );
        seasonOptions.forEach((label, idx) => {
          const opt = document.createElement("option");
          opt.textContent = label;
          opt.value = idx === 0 ? "-" : String(idx);
          const sVal = season ?? null;
          if (idx === 0 && (sVal === null || sVal === undefined)) opt.selected = true;
          if (idx !== 0 && sVal === idx) opt.selected = true;
          seasonSelect.appendChild(opt);
        });

        seasonSelect.addEventListener("change", async (e) => {
          const v = e.target.value;
          const newSeason = v === "-" ? null : Number(v);
          await updateDoc(docRef, { season: newSeason });
        });

        const episodeSelect = document.createElement("select");
        episodeSelect.className = "wheel-select";
        const epOptions = ["회차 없음"].concat(
          Array.from({ length: 50 }, (_, i) => `${i + 1}화`)
        );
        epOptions.forEach((label, idx) => {
          const opt = document.createElement("option");
          opt.textContent = label;
          opt.value = idx === 0 ? "-" : String(idx);
          const eVal = episodeNum ?? null;
          if (idx === 0 && (eVal === null || eVal === undefined)) opt.selected = true;
          if (idx !== 0 && eVal === idx) opt.selected = true;
          episodeSelect.appendChild(opt);
        });

        episodeSelect.addEventListener("change", async (e) => {
          const v = e.target.value;
          const newEp = v === "-" ? null : Number(v);
          await updateDoc(docRef, { episodeNum: newEp });
        });

        epRow.appendChild(epLabel);
        epRow.appendChild(seasonSelect);
        epRow.appendChild(episodeSelect);

        mid.appendChild(statusRow);
        mid.appendChild(epRow);

        // ===== 오른쪽 영역: 날짜 + 삭제 =====
        const right = document.createElement("div");
        right.className = "card-footer";

        const timeEl = document.createElement("div");
        timeEl.className = "card-meta";
        const ms = getCreatedAtMs(item);
        if (ms) {
          const date = new Date(ms);
          timeEl.textContent = date.toLocaleString("ko-KR");
        } else {
          timeEl.textContent = "";
        }

        const delBtn = document.createElement("button");
        delBtn.className = "secondary small-btn";
        delBtn.textContent = "삭제";
        delBtn.addEventListener("click", async () => {
          if (!confirm("이 항목을 삭제할까요?")) return;
          await deleteDoc(docRef);
        });

        right.appendChild(timeEl);
        right.appendChild(delBtn);

        card.appendChild(left);
        card.appendChild(mid);
        card.appendChild(right);

        grid.appendChild(card);
      });
    }
  </script>
</body>
</html>